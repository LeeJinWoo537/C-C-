# C++ 클래스 심화 - 연산자 오버로딩과 상속

## 연산자 오버로딩 (Operator Overloading)

### 기본 개념
연산자 오버로딩은 기존 연산자에 새로운 의미를 부여하는 기능입니다. 객체와 객체 간의 연산을 가능하게 만들어 코드를 더 직관적이고 간결하게 만듭니다.

### 예시 문제 1: 기본 시간 클래스

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);       // (1, 40), (2, 30)
    void addHours(int);
    void addMins(int);
    Time sum(Time&);
    void show();
    ~Time();
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;        // 1
    mins = m;         // 40
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;          // 1
}

void Time::addMins(int m) {
    mins += m;             // 40
    hours += mins / 60;    // 0 = 40 / 60 int로 타입을 생성했기 때문에 0이라는 값이 됨 1 = 1 += 0
    mins %= 60;            
}

Time Time::sum(Time& t) {          // t에 값을 받는건 day2 
    Time sum;                            // sum은 day1이 된다 임시 저장소 역할이라고 보면 됨.
    sum.mins = mins + t.mins;      // day1 = day1 + day2    그냥 mins도 day1이다.
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  // sum 하나만 반환하는 이유는 객체 변수이기 때문이다 객체 변수는 여러개에 (속성)변수를 가질 수 있다. 그래서 저 sum이라는 객체 변수에는 시간과 분이 같이 있다 객체 변수이기 때문에 객체 안에 있는 것을 다룰 수 있다. 동시에 다루는것도 가능.
}
       
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

int main() {
    Time day1(1, 40);
    Time day2(2, 30);

    day1.show();
    day2.show();

    Time total;
    total = day1.sum(day2);      // day1과 day2를 비교 이걸로 sum함수에 접근
    total.show();
    
    return 0;
}
```

### 예시 문제 2: 연산자 오버로딩 적용

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);       // (1, 40), (2, 30)
    void addHours(int);
    void addMins(int);
    Time operator+(Time&);        // 연산자 오버로딩
    void show();
    ~Time();
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;        // 1
    mins = m;         // 40
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;          // 1
}

void Time::addMins(int m) {
    mins += m;             // 40
    hours += mins / 60;    // 0 = 40 / 60 int로 타입을 생성했기 때문에 0이라는 값이 됨 1 = 1 += 0
    mins %= 60;            // 40
}

Time Time::operator+(Time& t) {         
    Time sum;                            
    sum.mins = mins + t.mins;      
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  
}
       
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

Time::~Time() {
    
}

int main() {
    Time day1(1, 40);
    Time day2(2, 30);

    day1.show();
    day2.show();

    Time total;
    total = day1.operator+(day2);      // 이런식으로도 호출 가능

    Time total2;
    total2 = day1 + day2;       // 연산자 오버로딩을 써야만 객체랑 객체끼리 더할 때도 코드를 간결하게 코드를 사용할 수 있음
    
    total.show();
    total2.show();
    
    return 0;
}
```

**연산자 오버로딩의 장점:**
- `day1.operator+(day2);` == `day1 + day2;`
- 가독성이 좋아지고 코드가 간결해짐
- `operator+`를 사용하면 이 함수가 더한다는 것을 명확히 알 수 있음

## friend 함수

### 개념
`friend` 함수는 클래스의 private 멤버에 접근할 수 있도록 허용하는 함수입니다.

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);      
    void addHours(int);
    void addMins(int);
    Time operator+(Time&);   
    void show();
    ~Time();
    friend Time operator*(int, Time&);  // friend 함수 선언
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;       
    mins = m;        
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;        
}

void Time::addMins(int m) {
    mins += m;            
    hours += mins / 60;  
    mins %= 60;           
}

Time Time::operator+(Time& t) {         
    Time sum;                            
    sum.mins = mins + t.mins;      
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  
}
       
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

Time operator*(int n, Time& t) {
    Time result;
    
    long resultMin = t.hours * n * 60 + t.mins * n;
    result.hours = resultMin / 60;
    result.mins = resultMin % 60;

    return result;
}

int main() {
    Time t1(1, 20);
    Time t2;

    t2 = 3 * t1;     // (t2 = operator*(3, t1);) == (t2 = 3 * t1;)
    t2.show();
    
    return 0;
}
```

## 스트림 추출 연산자 (<< 연산자)

### cout 출력문에 대한 이해
`cout`은 `iostream`에 있는 라이브러리를 통해서 출력을 할 수 있습니다.

```cpp
int a = 1;
int b = 3;

cout << a << b;   // 출력: 13 
```

`cout`은 왼쪽에서부터 오른쪽으로 값이 읽으며 출력됩니다. `a`라는 변수가 `cout`을 통해서 출력을 하고 그다음에 `b`라는 변수가 `cout`을 통해서 출력이 됩니다.

```cpp
cout <---- a
cout << a 
```

`<<`(꺽쇠) 연산자는 `a`가 `cout`을 출력할 수 있도록 도와주고 다시 꺽쇠(`<<`)을 통해서 `b`라는 변수를 출력하는 것입니다.

```cpp
(cout << a) << b
```

### 스트림 추출 연산자 오버로딩

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);      
    void addHours(int);
    void addMins(int);
    Time operator+(Time&);   
    void show();
    ~Time();
    friend Time operator*(int, Time&);
    friend std::ostream& operator<<(std::ostream&, Time&);  // 스트림 추출 연산자 오버로딩
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;       
    mins = m;        
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;        
}

void Time::addMins(int m) {
    mins += m;            
    hours += mins / 60;  
    mins %= 60;           
}

Time Time::operator+(Time& t) {         
    Time sum;                            
    sum.mins = mins + t.mins;      
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  
}
       
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

Time operator*(int n, Time& t) {
    Time result;
    
    long resultMin = t.hours * n * 60 + t.mins * n;
    result.hours = resultMin / 60;
    result.mins = resultMin % 60;

    return result;
}

std::ostream& operator<<(std::ostream& os, Time& t) {    // 참조를 하는 이유는 os는 std::ostream 객체에 대한 참조이다 그래서 이함수에 출력 스트림을 수정하는 함수로 출력하는 과정을 바꿔서 반환하는 것이다
    os << t.hours << "시간 " << t.mins << "분";

    return os;
}

int main() {
    Time t1(1, 20);
    
    t1.show();

    cout << t1;

    return 0;
}
```

### ostream 클래스 이해
- `ostream`은 문법이 아니라 클래스입니다
- C++ 표준 라이브러리에 포함된 출력 스트림 클래스입니다
- 데이터 출력할 때 사용됩니다
- 화면에 텍스트를 출력하려면 `std::cout`을 사용하고 파일에 출력하려면 `std::ofstream`을 사용할 수 있습니다
- 이들은 모두 `ostream` 클래스를 기반으로 하는 객체들입니다

```cpp
#include <iostream>

int main() {
    std::ostream& os = std::cout; // std::cout은 std::ostream 객체입니다.
    os << "Hello, world!" << std::endl;  // 출력: Hello, world!
    return 0;
}
```

## 상속 (Inheritance)

### 개념
1. 기존의 클래스에 새로운 기능을 추가할 수 있다.
2. 클래스가 나타내고 있는 데이터에 다른 것을 더 추가할 수 있다.
3. 클래스 메서드가 동작하는 방식을 변경할 수 있다.

### 상속의 특징
1. 파생 클래스형의 객체 안에는 기초 클래스형의 데이터 멤버들이 저장된다.
2. 파생 클래스형의 객체는 기초 클래스형의 메서드들을 사용할 수 있다.
3. 파생 클래스는 자기 자신의 생성자를 필요로 한다.
4. 파생 클래스는 부가적인 데이터 멤버들과 멤버 함수들을 임의로 추가할 수 있다.

### 상속 예제

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);      
    void addHours(int);
    void addMins(int);
    Time operator+(Time&);   
    void show();
    ~Time();
    friend Time operator*(int, Time&);
    friend std::ostream& operator<<(std::ostream&, Time&);
};

class NewTime : public Time {      // : 이거는 상속 기호 Time 클래스에 안에 있는 public을 접근할 수 있도록 상속 받음
private:
    int day;                   // 멤버 변수
public:
    NewTime();                  // 기본 생성자
    NewTime(int, int, int);    // 매개변수 3개를 받는 생성자
    void print();                 // 출력용 멤버 함수
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;       
    mins = m;        
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;        
}

void Time::addMins(int m) {
    mins += m;            
    hours += mins / 60;  
    mins %= 60;           
}

Time Time::operator+(Time& t) {         
    Time sum;                            
    sum.mins = mins + t.mins;      
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  
}
       
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

Time operator*(int n, Time& t) {
    Time result;
    
    long resultMin = t.hours * n * 60 + t.mins * n;
    result.hours = resultMin / 60;
    result.mins = resultMin % 60;

    return result;
}

std::ostream& operator<<(std::ostream& os, Time& t) {
    os << t.hours << "시간 " << t.mins << "분";

    return os;
}

NewTime::NewTime() : Time() {
    day = 0;    // 0으로 초기화
}

NewTime::NewTime(int h, int m, int d) : Time(h, m) {   // Time 클래스에 있는 시간과 분을 가져옴
    day = d;     // day를 초기화
}  

void NewTime::print() {
    cout << "일: " << day << endl;
    show();
}

int main() {
    NewTime temp;
    NewTime temp2(3, 30, 2);
    temp2.print();

    return 0;
}
```

### 상속의 중요 사항
- `:` 기호는 클래스가 다른 클래스를 상속 받고 있다는 것을 나타냄
- `class NewTime : public Time`은 `NewTime` 클래스가 `Time` 클래스의 모든(public, protected) 멤버를 물려받는다
- `private`는 상속되지 않음
- 생성자는 생성자만 호출(상속)이 가능하고(초기화 할 때만), 멤버 함수는 생성자를 호출할 수 없음

## 다형 상속과 가상 메서드 (virtual)

### virtual 키워드
`virtual`은 가상 함수라고 생각하면 됩니다. `virtual`로 설정된 함수는 해당 설정에 놓은 함수가 아니라 그 이름이 똑같은 다른 함수가 먼저 호출이 되는 것입니다.

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);      
    void addHours(int);
    void addMins(int);
    Time operator+(Time&);   
    virtual void show();  // 가상 함수
    virtual ~Time();        // 파괴자 역시 virtual로 설정
    int getHour() {
        return hours;
    }
    int getMins() {
        return mins;
    }
    friend Time operator*(int, Time&);
    friend std::ostream& operator<<(std::ostream&, Time&);
};

class NewTime : public Time {        // public Time == 다형 상속 == public 상속
private:
    int day;                  
public:
    NewTime();                  
    NewTime(int, int, int);    
    void show();  // 재정의
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;       
    mins = m;        
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;        
}

void Time::addMins(int m) {
    mins += m;            
    hours += mins / 60;  
    mins %= 60;           
}

Time Time::operator+(Time& t) {         
    Time sum;                            
    sum.mins = mins + t.mins;      
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  
}
      
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

Time operator*(int n, Time& t) {
    Time result;
    
    long resultMin = t.hours * n * 60 + t.mins * n;
    result.hours = resultMin / 60;
    result.mins = resultMin % 60;

    return result;
}

std::ostream& operator<<(std::ostream& os, Time& t) {
    os << t.hours << "시간 " << t.mins << "분";

    return os;
}

NewTime::NewTime() : Time() {
    day = 0;    // 0으로 초기화
}

NewTime::NewTime(int h, int m, int d) : Time(h, m) {  
    day = d;     // day를 초기화
}  

void NewTime::show() {
    cout << "일: " << day << endl;
    cout << "시간: " << getHour() << endl;
    cout << "분: " << getMins() << endl;
}

int main() {
    Time temp1(2, 30);
    NewTime temp2(3, 30, 2);

    temp1.show();
    temp2.show();

    return 0;
}
```

### virtual의 동작 원리
1. **기초 클래스에서 가상메서드를 선언하면** 그 함수는 기초 클래스 및 파생되는 클래스에서 모두 가상이 된다.
2. **객체에 대한 참조를 사용하여 객체를 지시하는 포인터를 사용하여 가상 메서드가 호출되면** 참조나 포인터를 위해 정의된 메서드를 사용하지 않고 객체형을 위해 정의된 메서드를 사용한다. → 동적 결합
3. **상속을 위해 기초 클래스로 사용함**, 클래스를 정의할 때 파생 클래스에서 다시 정의해야 되는 클래스 메서드들은 가상 함수로 선언해야한다.

### virtual이 필요한 이유
`virtual`은 부모 클래스의 포인터나 참조를 사용해도 자식 클래스에서 재정의한 함수를 호출할 수 있도록 보장합니다. 이것이 다형성을 가능하게 만들어줍니다.

```cpp
int main() {
    Time* ptr;                // 부모 클래스 포인터
    Time t(2, 30);            // 부모 클래스 객체
    NewTime nt(3, 30, 2);     // 자식 클래스 객체

    ptr = &t;
    ptr->show();  // 부모 클래스의 show() 호출

    ptr = &nt;
    ptr->show();  // 자식 클래스의 show() 호출 (virtual이 있을 때만)
}
```

## 동적 결합 (Dynamic Binding)

### 개념
다형 상속 + virtual(가상 메서드) + 동적 결합

다형 상속은 첫번째 단계 public으로 상속을 함
메서드는 클래스 안에서 정의된 함수

### 동적 결합 예제

```cpp
#include "time.h"   // 시간 라이브러리

using namespace std;

const int MAX = 3;

class Time {
private:
    int hours;
    int mins;

public:
    Time();
    Time(int, int);      
    void addHours(int);
    void addMins(int);
    Time operator+(Time&);   
    virtual void show();
    virtual ~Time();        // 파괴자 역시 virtual로 설정
    int getHour() {
        return hours;
    }
    int getMins() {
        return mins;
    }
    friend Time operator*(int, Time&);
    friend std::ostream& operator<<(std::ostream&, Time&);
};

class NewTime : public Time {     
private:
    int day;                  
public:
    NewTime();                  
    NewTime(int, int, int);    
    void show();
};

Time::Time() {
    hours = mins = 0;
}

Time::Time(int h, int m) {
    hours = h;       
    mins = m;        
}

Time::~Time() {
    
}

void Time::addHours(int h) {
    hours += h;        
}

void Time::addMins(int m) {
    mins += m;            
    hours += mins / 60;  
    mins %= 60;           
}

Time Time::operator+(Time& t) {         
    Time sum;                            
    sum.mins = mins + t.mins;      
    sum.hours = hours + t.hours;
    sum.hours += sum.mins / 60;
    sum.mins %= 60;

    return sum;                  
}
      
void Time::show() {
    cout << "시간: " << hours << endl;
    cout << "분: " << mins << endl;
}

Time operator*(int n, Time& t) {
    Time result;
    
    long resultMin = t.hours * n * 60 + t.mins * n;
    result.hours = resultMin / 60;
    result.mins = resultMin % 60;

    return result;
}

std::ostream& operator<<(std::ostream& os, Time& t) {
    os << t.hours << "시간 " << t.mins << "분";

    return os;
}

NewTime::NewTime() : Time() {
    day = 0;    // 0으로 초기화
}

NewTime::NewTime(int h, int m, int d) : Time(h, m) {   // Time 클래스에 있는 시간과 분을 가져옴
    day = d;     // day를 초기화
}  

void NewTime::show() {
    cout << "일: " << day << endl;
    cout << "시간: " << getHour() << endl;
    cout << "분: " << getMins() << endl;
}

int main() {
    Time* times[MAX];    // 3
    int day;
    int hours;
    int mins;

    for (int i = 0; i < MAX; i++) {
        cout << i + 1 << "번째 원소를 정의합니다." << endl;
        cout << "시간을 입력하십시오." << endl;
        cin >> hours;
        cout << "분을 입력하십시오." << endl;
        cin >> mins;
        char check;
        cout << "일 정보가 있다면 1, 없다면 0을 입력하십시오." << endl;
        cin >> check;

        if (check == '0') {
            times[i] = new Time(hours, mins);   // Time::Time(int h, int m) 여기 함수 호출
        }

        else {
            cout << "일을 입력하십시오." << endl;
            cin >> day;
            times[i] = new NewTime(hours, mins, day);   // NewTime::NewTime(int h, int m, int d) : Time(h, m) 여기 함수로 호출
        }
    }

    for (int i = 0; i < MAX; i++) {
        cout << i + 1 << "번쨰 정보입니다." << endl;    // 출력
        times[i]->show();
    }

    for (int i = 0; i < MAX; i++) {
        delete times[i];   // times 객체에 대한 파괴자만 호출이 됨 그래서 파괴자 역시 virtual로 한다 그래서 이런식으로 작성하면 굳이 NewTime에서 delete를 해주지 않아도 됨
    }
    
    return 0;
}
```

### 동적 결합의 특징
- **동적 바인딩**: 프로그램 실행 중에 어떤 함수가 호출될지 결정되는 방식
- 포인터로 만든 객체로 만들기 때문에 `Time* times`로 부모 클래스여도 자식 클래스에 있는 함수를 호출할 수 있음
- `virtual` 함수 (다형성): `Time` 클래스의 `show` 함수는 `virtual`로 선언되어 있습니다. 이 덕분에 `times[i]->show()`가 호출될 때, 실제 객체가 `NewTime`일 경우에도, `NewTime` 클래스의 `show` 함수가 호출됩니다.

## 주요 포인트
1. **연산자 오버로딩**: 객체 간 연산을 직관적으로 만들 수 있음
2. **friend 함수**: 클래스의 private 멤버에 접근 가능
3. **스트림 추출 연산자**: `cout`과 함께 사용할 수 있는 출력 연산자
4. **상속**: 기존 클래스의 기능을 확장하여 새로운 클래스 생성
5. **virtual 함수**: 다형성을 통한 동적 바인딩 구현
6. **동적 결합**: 실행 시점에 실제 객체 타입에 맞는 함수 호출
